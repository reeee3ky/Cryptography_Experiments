# RSA大礼包

## 摘要

通过使用一些针对RSA不当使用方式的攻击方法来破解RSA加密并得到明文

## 题目描述

题目选自2016年全国高校密码数学挑战赛赛题三。RSA密码算法是使用最为广泛的公钥密码体制，当前对于模数规模为1024比特的RSA算法一般情况下认为是安全的，但是如果选取参数不当，也会存在被破译的风险。已知一款加密软件采用RSA加密体制，且我们已经得到了通过使用此软件发送某个明文的所有参数和加密过程的全部数据。Alice使用该软件发送了一条信息，且所有加密数据都被截获，我们需要尝试从加密数据恢复出Alice原本发送的信息，并给出加密使用的全部参数。

## 过程

已知给出的21组数据的格式为如下

```
1024bit模数N | 1024bit加密指数e | 1024bit密文m^e mod N
```

从中可以分离出e，收集这21组数据中所有用到的e值，可以得到

```
3
5
65537
46786465362686334917265996843779843233606992585424976481745055335468678697948774988450305612127967926533923268260412557000125153569622340353246096040604284883505587337829322949633637609180797447754513992039018904786537115087888005528547900640339270052628915440787357271345416818313808448127098885767015748889
152206992575706893484835984472544529509325440944131662631741403414037956695665533186650071476146389737020554215956181827422540843366433981607643940546405002217220286072880967331118344806315756304650248634546597784597963886656422706197757265316981889118026978865295597135470735576032282694348773714479076093197
```

分别对应以下数据

```
['Frame7', 'Frame11', 'Frame15']
['Frame3', 'Frame8', 'Frame12', 'Frame16', 'Frame20']
['Frame1', 'Frame2', 'Frame5', 'Frame6', 'Frame9', 'Frame10', 'Frame13', 'Frame14', 'Frame17', 'Frame18', 'Frame19']
['Frame0']
['Frame4']
```

21组数据中共使用了5个e值，其中存在3、5这种数值非常小的e，使用这种数值非常小的e进行加密的RSA是不安全的，容易受到攻击，接下来通过几种常见的攻击方法尝试破译

### 低指数广播攻击 (3, 8, 12, 16, 20)

此种攻击方法主要针对加密指数较小，且多次使用此加密指数对相同明文进行加密的情况，具体原理如下图所示

![image-20220107225429153](https://s2.loli.net/2022/01/07/51pD6xFubgzTl7J.png)

在题目所给数据中，数据帧 **3 8 12 16 20** 可以利用此种攻击方式进行破译，以下为代码实现

```python
# coding=utf-8
import re
import gmpy2
import libnum
from functools import *

# 中国剩余定理
def CRT(C, N):
	mul_n = reduce(lambda x, y: x * y, N)
	result = 0
	for a, n in zip(C, N):
		m = mul_n // n
		d, r, s = gmpy2.gcdext(n, m)
		result += a * s * m
	return result % mul_n, mul_n

# 按照格式分割数据
Data = []
N = []
C = []
for i in [3, 8, 12, 16, 20]:
    with open('./Frame' + str(i)) as f:
        data = re.findall('(.{256})(.{256})(.{256})', f.read().strip())
        Data += data

N = [int(n, 16) for n,e,c in Data]
C = [int(c, 16) for n,e,c in Data]
e = 5
c, n = CRT(C, N)
m = int(gmpy2.iroot(gmpy2.mpz(c), e)[0])
print(int(hex(m)[2:][16:24], 16), ',', libnum.n2s(m)[-8:])
```

![image-20220108221718262](https://s2.loli.net/2022/01/08/41qo6Hzs8L5pDej.png)

得到一部分明文和对应通信序号

```
1 , b't is a f'
```

### 共模攻击 (0, 4)

在按照格式解析题目中所给数据时，可以发现 Frame0 与 Frame4 两个数据帧中前1024位相同，即使用了相同的模数N，此时存在共模攻击，原理如下图所示

![image-20220108014640454](https://s2.loli.net/2022/01/08/eWBZ8b3KO1P7NDT.png)

在题目所给数据中，数据帧 **0 4** 可以利用此种攻击方式进行破译，以下为代码实现

```python
# coding=utf-8
import gmpy2
import libnum
import re

Data = []
for i in [0, 4]:
    with open('./Frame' + str(i)) as f:
        data = re.findall('(.{256})(.{256})(.{256})', f.read().strip())
        Data += data

E = [int(e, 16) for n,e,c in Data]
C = [int(c, 16) for n,e,c in Data]
N = [int(n, 16) for n,e,c in Data]

n = N[0]
c1, c2 = C[0], C[1]
e1, e2 = E[0], E[1]
_, s1, s2 = gmpy2.gcdext(e1, e2) # s1*e1 + s2*e2 = 1

# 若 s1 < 0，则 c1^s1 == (c1^-1)^(-s1)，其中 c1^-1 为 c1 模 n 的逆元
if s1 < 0:
    s1 = -s1
    c1 = gmpy2.invert(c1, n)
if s2 < 0:
    s2 = -s2
    c2 = gmpy2.invert(c2, n)

m = int(pow(c1, s1, n) * pow(c2, s2, n) % n)
print(int(hex(m)[2:][16:24], 16), ',', libnum.n2s(m)[-8:])
```

![image-20220108221847749](https://s2.loli.net/2022/01/08/yjp1f4Qi93grbJT.png)

得到一部分明文和对应通信序号

```
0 , b'My secre'
```

### 相同因子 (1, 18)

对于不同的模数N，如果具有相同的因子p（或q），那么此时的RSA加密系统是不安全的，可以利用欧几里得算法直接将N分解，原理也很简单

```
n1 = p * q1
n2 = p * q2
gcd(n1, n2) = p
n1 / p = q1
n2 / p = q2
```

在题目所给数据中，数据帧 **1 18** 可以利用此种攻击方式进行破译，并可以直接得到加密参数，以下为代码实现

```python
import gmpy2
import re
import libnum

Data = []
for i in [1, 18]:
    with open('./Frame' + str(i)) as f:
        data = re.findall('(.{256})(.{256})(.{256})', f.read().strip())
        Data += data

N = [int(n, 16) for n,e,c in Data]
E = [int(e, 16) for n,e,c in Data]
C = [int(c, 16) for n,e,c in Data]

n1, n2 = gmpy2.mpz(N[0]), gmpy2.mpz(N[1])
e1, e2 = gmpy2.mpz(E[0]), gmpy2.mpz(E[1])
c1, c2 = gmpy2.mpz(C[0]), gmpy2.mpz(C[1])
p = gmpy2.gcd(n1, n2)
q1 = n1 // p
q2 = n2 // p
phi_n1 = (p-1) * (q1-1)
phi_n2 = (p-1) * (q2-1)
d1 = gmpy2.invert(e1, phi_n1)
d2 = gmpy2.invert(e2, phi_n2)
m1 = int(pow(c1, d1, n1))
m2 = int(pow(c2, d2, n2))

print('[+] Frame1')
print('p = %d\nq = %d\nn = %d\nphi = %d\ne = %d\nd = %d\nc = %d\nm = %d' %(int(p), int(q1), int(n1), int(phi_n1), int(e1), int(d1), int(c1), int(m1)))
print(int(hex(m1)[2:][16:24], 16), ',', libnum.n2s(m1)[-8:])
print()
print('[+] Frame18')
print('p = %d\nq = %d\nn = %d\nphi = %d\ne = %d\nd = %d\nc = %d\nm = %d' %(int(p), int(q2), int(n2), int(phi_n2), int(e2), int(d2), int(c2), int(m2)))
print(int(hex(m2)[2:][16:24], 16), ',', libnum.n2s(m2)[-8:])
```

![image-20220108222233599](https://s2.loli.net/2022/01/08/ePHnxaFlDR39XTI.png)

得到数据帧 **1** **18** 加密用全部参数以及对应明文和通信序号

```
[+] Frame1
p = 7273268163465293471933643674908027120929096536045429682300347130226398442391418956862476173798834057392247872274441320512158525416407044516675402521694747
q = 12775796067504534889308793837705093856447186276434607181291462366302734214583227473619414509043813033676998357747882057607288385639737162184366176530607467
n = 92921790800705826977497755832938592891062287903332844896046168726101016067456726822505517352409138948392871113192427210529297191908638888388136391240683157994654207338463678065440899870434887094216772312358731142317774259942199808535233769089985063860828267808621928898445383706310204223006136919334252875849
phi = 92921790800705826977497755832938592891062287903332844896046168726101016067456726822505517352409138948392871113192427210529297191908638888388136391240683137945589976368635316823003387257313909717933959832321867550508277730809542833888803287199302221213737198562391906575067264259399148078799435877755200573636
e = 65537
d = 3370235084506122506759726042005203706334666804190337859802886050047181213548753218137778884396242172823441027756204883949954062974607239234304289210356040387821648440243620368467873895824269701077696911995194762768484614281005894626755655792494947584189897630083854340737825764752609594325438440597282630629
c = 1626661141529320283833484152716550848856697186049377493478368799832043379420727509223318694347625977694500761460048670101820769656612419734057871562023463159698522348510157125720014700549254630959391701883372400982386084212421115166791728704867253734354874934210987301137512341070190760227227749365878233484
m = 7985094500508197619216095180801677871569877246162537093666322216189080945782512671212961203038444555780441863690547949326495942981239718080535505859471726
11 , b'. Imagin'

[+] Frame18
p = 7273268163465293471933643674908027120929096536045429682300347130226398442391418956862476173798834057392247872274441320512158525416407044516675402521694747
q = 12840807874760119497562989864651565491645077946976950748211992253853323703532620362223764981952516328133916264333884385029280730688894521589959051436522977
n = 93394639108667212482180458616036741615058981058942739509025631675767304945732437421192075466824789572910657586684470553691049259504106442090140927782673066834126848556317079995332229262871079799089771973100731889841015960713908117908583988637159206246729697336281050046919985463146705713899703248595045701819
phi = 93394639108667212482180458616036741615058981058942739509025631675767304945732437421192075466824789572910657586684470553691049259504106442090140927782673046720050810330904110498698689703278467224915288950720301377501631880991762193869264902396003454896344171172144441721214444023890600412333596614141087484096
e = 65537
d = 46303288431249753085600614330107661451645580550943245679955762766208878531161608811654071990906984799472253632399283110769940225213351641307854479538499056014585515499210161562532887160518851291208745725114119235817675863667612756201842550141918980980087810087817831155007090883382721036933994860714897150209
c = 49047978458885807127192385282227726754593888749388775377492411121925201201621099927332087316607446894372751446254341808051569111053293066232980434901592875347200122022210780536817524813076908750647137301610117592355818408280291766068780616226847056325075159440352473034526412778650516438709293396458312728764
m = 7985094500508197619216095180632447543559573604830846774809932829993009346943656679076091111448196673223946159159299511453928830060256372341748824036810818
10 , b'm A to B'
```

### Fermat 分解法 (10, 14)

已知模数N=p*q，如果p与q两数大小接近，则利用费马分解法可以快速分解N，进而破译对应的RSA密文

费马分解法原理如下

```
N = p * q
令 a = (p + q) / 2, b = (p - q) / 2
则 N = a * a - b * b, a >= sqrt(N)
令 a 从 sqrt(N) 开始遍历，如果 a*a-N 为完全平方数，则找到分解且唯一
p = a + b
q = a - b
```

在题目所给数据中，数据帧 **10 14** 可以利用此种攻击方式进行破译，并可以直接得到加密参数，以下为代码实现

```python
import gmpy2
import re
import libnum

Data = []
for i in [10, 14]:
    with open('./Frame' + str(i)) as f:
        data = re.findall('(.{256})(.{256})(.{256})', f.read().strip())
        Data += data

N = [int(n, 16) for n,e,c in Data]
E = [int(e, 16) for n,e,c in Data]
C = [int(c, 16) for n,e,c in Data]

n1, n2 = gmpy2.mpz(N[0]), gmpy2.mpz(N[1])
e1, e2 = gmpy2.mpz(E[0]), gmpy2.mpz(E[1])
c1, c2 = gmpy2.mpz(C[0]), gmpy2.mpz(C[1])

def fermat(n):
    a = gmpy2.iroot(n, 2)[0] + 1
    b = a * a - n
    p, q = gmpy2.mpz(0), gmpy2.mpz(0)
    # print(a, b)
    while 1:
        if gmpy2.iroot(b, 2)[1] == True:
            b = gmpy2.iroot(b, 2)[0]
            p = a + b
            q = a - b
            break
        a += 1
        b = a * a - n
    return p, q

p1, q1 = fermat(n1)
p2, q2 = fermat(n2)
phi_n1 = (p1-1) * (q1-1)
phi_n2 = (p2-1) * (q2-1)
d1 = gmpy2.invert(e1, phi_n1)
d2 = gmpy2.invert(e2, phi_n2)
m1 = int(pow(c1, d1, n1))
m2 = int(pow(c2, d2, n2))

print('[+] Frame10')
print('p = %d\nq = %d\nn = %d\nphi = %d\ne = %d\nd = %d\nc = %d\nm = %d' %(int(p1), int(q1), int(n1), int(phi_n1), int(e1), int(d1), int(c1), int(m1)))
print(int(hex(m1)[2:][16:24], 16), ',', libnum.n2s(m1)[-8:])
print()
print('[+] Frame14')
print('p = %d\nq = %d\nn = %d\nphi = %d\ne = %d\nd = %d\nc = %d\nm = %d' %(int(p2), int(q2), int(n2), int(phi_n2), int(e2), int(d2), int(c2), int(m2)))
print(int(hex(m2)[2:][16:24], 16), ',', libnum.n2s(m2)[-8:])
```

![image-20220108235306318](https://s2.loli.net/2022/01/08/1fR4zcLetITj6H7.png)

得到数据帧 **10** **14** 加密用全部参数以及对应明文和通信序号

```
[+] Frame10
p = 9686924917554805418937638872796017160525664579857640590160320300805115443578184985934338583303180178582009591634321755204008394655858254980766008932978699
q = 9686924917554805418937638872796017160525664579857640590160320300805115443578184985934338583303180178582009591634321755204008394655858254980766008932978633
n = 93836514358344173762895084384953633159699750987954044414830106276642828025218933012478990865656107605541657809389659063108620208004740646099662700112782252200834393363574089818787717951026690934986964275526538236750596344542450864284576226592039259070002692883820960186403938410354082341916474419847211138467
phi = 93836514358344173762895084384953633159699750987954044414830106276642828025218933012478990865656107605541657809389659063108620208004740646099662700112782232826984558253963251943509972358992369883657804560245357916109994734311563707914604357914872652709645528864637691542893530393564770625406512887829345181136
e = 65537
d = 39442062667337640640347756069889035699684896172622641584071973657669407870526663528918912391110804525838168480022841115880390632313145102432326905412313840543280034579274695229990222447978436809514038515969282611579444053680831369484773582060225475139121494478449951766667502048484500914263289600089033243889
c = 78852785408127338210375705302361611580033298047358566712385067002412358292419274287993295604646693755514055710305938805847184012173449160624823261013152092151242661538772012880714981492275731658527465442787266554947828301571586721387286510359738598116104180351027973922256460236377354127082438812404967605644
m = 7985094500508197619216095180293986887538966322167466137097154057600866149265944694802350928267700908110954750096802635708794604218289672526108082271905140
8 , b'will get'

[+] Frame14
p = 10954856299233465126359914171500305822846165431085183673999109759449706417636519711881707731622506407722143163847672064459333431572992021257881551867597529
q = 10954856299233465126359914171500305822846165431085183673999109759449706415739193445885099004577509868426540084786683485568001351280541116090063034118634519
n = 120008876536855131221255979370745233738591934188224528487535120483456214085493237482915446419599357910343450285858995374277365393767669569942204888383426461862651659865189178784473131914234181752055950431093341514138390898892413182538823693941124637301582389014479754627419560568004831093116617428970538503551
phi = 120008876536855131221255979370745233738591934188224528487535120483456214085493237482915446419599357910343450285858995374277365393767669569942204888383426439952939061398258926064644788913622536059725088260725993515918871999479579806825665927134388437285306240331231120271869533233221977559979269484384552271504
e = 65537
d = 33045152905749236279029943447586378504457482709930265973206872213321495329154690687957827579658666293087231699019049247359649295755548240828494276756142538343084643819414690629149638536021366338614812132887701283065626502626127183026015339748038111894817224056905210742422716888577808063344155166016198945505
c = 35133765260146855599194761500993159592311136378033858818728078464540389548474611501950689942825550399101504201020687961256642455745888410410524955937773951578993882275525944145131794970001708655718844507774877602125183877782393564092461821246419013099835940432551540513624090850765797735157630551978900512155
m = 7985094500508197619216095180463217215549269963499156455953543443796937748104800686939221019857948790667450454628051073581361717139273016540010317514961519
9 , b' you fro'
```

### Pollard p-1 分解法 (2, 6, 19)

Pollard p-1 分解法可以在模数N的因子p和q相差较大时快速分解N，得到p和q，进而破译RSA得到明文与一系列参数

使用此种方法可以成功分解数据帧 **2** **6** **19** 中的N值，得到因子，进而计算得到明文和其余参数

```python
import gmpy2
import re
import libnum

Data = []
for i in [2, 6, 19]:
    with open('./Frame' + str(i)) as f:
        data = re.findall('(.{256})(.{256})(.{256})', f.read().strip())
        Data += data

N = [int(n, 16) for n,e,c in Data]
E = [int(e, 16) for n,e,c in Data]
C = [int(c, 16) for n,e,c in Data]

n1, n2, n3 = gmpy2.mpz(N[0]), gmpy2.mpz(N[1]), gmpy2.mpz(N[2])
e1, e2, e3 = gmpy2.mpz(E[0]), gmpy2.mpz(E[1]), gmpy2.mpz(E[2])
c1, c2, c3 = gmpy2.mpz(C[0]), gmpy2.mpz(C[1]), gmpy2.mpz(C[2])

def Pollard(n):
    a = i = 2
    while 1:
        a = gmpy2.powmod(a, i, n)
        p = gmpy2.gcd(a-1, n)
        if p != 1:
            q = n // p
            return p, q
        i += 1

p1, q1 = Pollard(n1)
p2, q2 = Pollard(n2)
p3, q3 = Pollard(n3)
phi_n1 = (p1-1) * (q1-1)
phi_n2 = (p2-1) * (q2-1)
phi_n3 = (p3-1) * (q3-1)
d1 = gmpy2.invert(e1, phi_n1)
d2 = gmpy2.invert(e2, phi_n2)
d3 = gmpy2.invert(e3, phi_n3)
m1 = int(pow(c1, d1, n1))
m2 = int(pow(c2, d2, n2))
m3 = int(pow(c3, d3, n3))

print('[+] Frame2')
print('p = %d\nq = %d\nn = %d\nphi = %d\ne = %d\nd = %d\nc = %d\nm = %d' %(int(p1), int(q1), int(n1), int(phi_n1), int(e1), int(d1), int(c1), int(m1)))
print(int(hex(m1)[2:][16:24], 16), ',', libnum.n2s(m1)[-8:])
print()
print('[+] Frame6')
print('p = %d\nq = %d\nn = %d\nphi = %d\ne = %d\nd = %d\nc = %d\nm = %d' %(int(p2), int(q2), int(n2), int(phi_n2), int(e2), int(d2), int(c2), int(m2)))
print(int(hex(m2)[2:][16:24], 16), ',', libnum.n2s(m2)[-8:])
print()
print('[+] Frame19')
print('p = %d\nq = %d\nn = %d\nphi = %d\ne = %d\nd = %d\nc = %d\nm = %d' %(int(p3), int(q3), int(n3), int(phi_n3), int(e3), int(d3), int(c3), int(m3)))
print(int(hex(m3)[2:][16:24], 16), ',', libnum.n2s(m3)[-8:])
```

![image-20220109005650010](https://s2.loli.net/2022/01/09/5hKv6rY3JnA1uLC.png)

得到数据帧 **2** **6** **19** 加密用全部参数以及对应明文和通信序号

```
[+] Frame2
p = 1719620105458406433483340568317543019584575635895742560438771105058321655238562613083979651479555788009994557822024565226932906295208262756822275663694111
q = 52484065122572767557293534477361686456679280880304125291106733197354892893647364164212186415880889674435558369420400890814461263958618375991691022752189839
n = 90252653600964453524559669296618135272911289775949194922543520872164147768650421038176330053599968601135821750672685664360786595430028684419411893316074286312793730822963564220564616708573764764386830123818197183233443472506106828919670406785228124876225200632055727680225997407097843708009916059133498338129
phi = 90252653600964453524559669296618135272911289775949194922543520872164147768650421038176330053599968601135821750672685664360786595430028684419411893316074232109108502791789573443689571029344288500530313923950345637729141059291557942992893110619160764430762755079128485254769956012927589881371167545835082454180
e = 65537
d = 82588951916582086558354707830031628066390525511439722872496147729457074171559623579070004210972386849372377466642389866228925548943797858644749836976846725484038865517634379031157223458074609303962707884815449724367792965925100522714951639990422347138894120078817973323451848604716319336643295543873255793553
c = 39632263504870478574861695051251850807454294787974709214866410237055871793939895562441267574482198916367858789237648434983815369123479208726344716594227785308836601932181727610859898951190206345056426253251079929822424252271957269630987623886812686545521745791771387808772030614435314730783528512800343192265
m = 7985094500508197619216095179955526231518359039504085499384375285208722951588232710528610745087205142997963341034305759963660378376322965694370023122954611
6 , b' That is'

[+] Frame6
p = 920724637201
q = 159482692259010816139523195494724350795654007589889398757383554027183924116413427533184220914037106543253535103452324841452565420868944985464229649420240708554088156331324206733727690785373464575525698274552058386560106163093965065830071277465943834308083708065429495092746028681968670036721164931
n = 146839643970016464813197409569004275595828791825722617066607993001682901023784267554815946189374651530288894322286859792246413142980277245909181062525398546369553995023529451396820549308690493928593324007689135648753323161394735120908960458860801743476353228970081369439513197105039143930008573928693059198131
phi = 146839643969856982120938398752864752400334067474926963059018103602925517469757083630699532761841467309374857215743606257142960818138824680488312117539934316720133754314975363240489225101956766237807950543113609950478771103008175014745866493794971672198887285135773285731447767609946397901326605257735613396000
e = 65537
d = 70723306863428836239794628326505270450532444876116843751741862462827776049146014385813063637754641128224016479468802836668104402468102004052879625099531969837969726337064518374140445707665369582013335350922091308525907653179929571699242807523052334299065827781416356624702821072187589449553295008322392493473
c = 47190775807472506173587993082023759909601357229808667044044468676457696140445235738005020994278091230440755033222450219378047807646817722376918364211727971804312327204294555178996480944188624972632371674822397258127227029990196956900925820980263353418653201918881814896866168764140848945600419602253279143149
m = 7985094500508197619216095180124756559528662680835775818240764671404794550427088702665480836677453025554459045565554197836227491297306315958671527603954464
7 , b' "Logic '

[+] Frame19
p = 1085663496559
q = 86725761611859895386396141031497189948984447138542215420462553101081991008304507461163078354877970282649251051457532902955009856009405853917396630017011320500357081664483071782135584899953560478866041032397335990722689211113937797406269980402604895207480485168493674422769645640726941944110986793
n = 94154993593274109828418786834159728190797445711539243887409583756844882924221269576486611543668906670821879426307992404721925623741478677756083992902711765865503466687919799394258306574702184666207180530598057989884729154273423032471322027993848437082723045300784582836897839491321003685598931080456249945287
phi = 94154993593187384066806926938773332049765948521590259440271041541424420371120187585478307036207743592467001456025343153670468090838523667900074587048794369235486455367419442312593823502920049081307226970119191948852331818282700343260208090196442167102320440405577102351729345816898234039958204137426475461936
e = 65537
d = 47956020051888168212612954837973264321241243292349098373685816663148254451500554825568242197058371318744350650809862436021182307279703374193272345632066711095725130539458031102955305072363264084929661660780606790861510842642729106581408151895223149333589518908985209522876017568214337736756410182145898514113
c = 52958695992371180409414011678115981405835026800648278393085136639708219930134280877954018305615378579281651249142230848262822421713895227069561145945972448893229231020632492517869034217943260664130647322694583182800800838539691542175229797652856708373533581250607375664993806654537737027000328299623032632769
m = 7985094500508197619216095179786295903508055398172395180527985899012651352749376718391740653496957260441467636503057322091093265455339620683498933545692718
5 , b'instein.'
```

### 明文语义分析

汇总目前已破译出的全部明文和通信序号，对应关系如下

```
0 ,  b'My secre'
1 ,  b't is a f'

5 ,  b'instein.'
6 ,  b' That is'
7 ,  b' "Logic '
8 ,  b'will get'
9 ,  b' you fro'
10 , b'm A to B'
11 , b'. Imagin'
```

按照顺序连起来，可以得到以下信息

```
My secret is a f
instein. That is "Logic will get you from A to B. Imagin
```

虽然明文暂不完整，但可以根据已知明文进行推测，搜索已有的完整句子可以发现后面的话是爱因斯坦说的一句名言

```
Logic will get you from A to B. Imagination will take you everywhere.    -- Albert Einstein
```

按照明文分为8字节一组，可以将前后几组并未解出的明文推测出来

```
4 ,  b'Albert E'

12 , b'ation wi'
13 , b'll take '
14 , b'you ever'
15 , b'ywhere."'
```

最终得到如下明文

```
My secret is a f
Albert Einstein. That is "Logic will get you from A to B. Imagination will take you everywhere."
```

剩余的 2 3 组明文暂未解出，还没搞懂 coppersmith 攻击。。。

## 总结

通过本次实验，学习了多种常见的RSA攻击方式，每种攻击方法都非常精妙，原理简单，代码实现也容易，后面的几种关于大整数的分解方法，也是单纯的数学问题，不包含太多的密码学知识，但是却能将其完美地利用在密码中。写完这么多内容，虽然明文没能完全破译，不过回看还是挺有成就感的。

这几种攻击方式和大数分解方式代码实现起来都比较简单，基本没什么代码上的难点，但给我留下最深刻印象的一个错误就是 python3 中的 `/` 得到的是小数，必须要用 `//` 才能得到 int 类型数据，之前习惯用 python2 就没有这种问题，debug 的时候找了半天才找到，还连续犯了两次，以后再也不会忘了。

## 参考文献

+ https://blog.csdn.net/weixin_40328085/article/details/100837778
+ https://www.runoob.com/python/python-reg-expressions.html
+ https://www.tr0y.wang/2017/11/06/CTFRSA/
+ https://www.tr0y.wang/2017/10/31/RSA2016/
+ https://blog.csdn.net/u011815404/article/details/81335633
+ https://www.cnblogs.com/organic/p/6240167.html
+ https://www.cnblogs.com/gwind/p/8013154.html
+ RSA加密体制破译报告—双河安团队

